import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/*!
 * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 *
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 *
 */
import { removeNils, warn, clone } from './util';
import { AuthSdkError } from './errors';
import { isRefreshTokenError, validateToken } from './oidc/util';
import { isLocalhost, isIE11OrLess } from './features';
import { TOKEN_STORAGE_NAME } from './constants';
import SdkClock from './clock';
import { isIDToken, isAccessToken, isRefreshToken } from './types';
import { ID_TOKEN_STORAGE_KEY, ACCESS_TOKEN_STORAGE_KEY, REFRESH_TOKEN_STORAGE_KEY } from './constants';
import { TokenService } from './services/TokenService';
var DEFAULT_OPTIONS = {
  autoRenew: true,
  autoRemove: true,
  storage: undefined,
  // will use value from storageManager config
  expireEarlySeconds: 30,
  storageKey: TOKEN_STORAGE_NAME,
  syncStorage: true,
  _storageEventDelay: 0
};
export var EVENT_EXPIRED = 'expired';
export var EVENT_RENEWED = 'renewed';
export var EVENT_ADDED = 'added';
export var EVENT_REMOVED = 'removed';
export var EVENT_ERROR = 'error';

function defaultState() {
  return {
    expireTimeouts: {},
    renewPromise: {}
  };
}

export class TokenManager {
  constructor(sdk) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.sdk = sdk;
    this.emitter = sdk.emitter;

    if (!this.emitter) {
      throw new AuthSdkError('Emitter should be initialized before TokenManager');
    }

    options = Object.assign({}, DEFAULT_OPTIONS, removeNils(options));

    if (isIE11OrLess()) {
      options._storageEventDelay = options._storageEventDelay || 1000;
    }

    if (!isLocalhost()) {
      options.expireEarlySeconds = DEFAULT_OPTIONS.expireEarlySeconds;
    }

    this.options = options;
    var storageOptions = removeNils({
      storageKey: options.storageKey,
      secure: options.secure
    });

    if (typeof options.storage === 'object') {
      // A custom storage provider must implement getItem(key) and setItem(key, val)
      storageOptions.storageProvider = options.storage;
    } else if (options.storage) {
      storageOptions.storageType = options.storage;
    }

    this.storage = sdk.storageManager.getTokenStorage(storageOptions);
    this.clock = SdkClock.create();
    this.state = defaultState();
    this.on = this.emitter.on.bind(this.emitter);
    this.off = this.emitter.off.bind(this.emitter);
  }

  start() {
    if (this.service) {
      this.stop();
    }

    this.service = new TokenService(this, this.getOptions());
    this.service.start();
  }

  stop() {
    if (this.service) {
      this.service.stop();
      this.service = null;
    }
  }

  getOptions() {
    return clone(this.options);
  }

  getExpireTime(token) {
    var expireTime = token.expiresAt - this.options.expireEarlySeconds;
    return expireTime;
  }

  hasExpired(token) {
    var expireTime = this.getExpireTime(token);
    return expireTime <= this.clock.now();
  }

  emitExpired(key, token) {
    this.emitter.emit(EVENT_EXPIRED, key, token);
  }

  emitRenewed(key, freshToken, oldToken) {
    this.emitter.emit(EVENT_RENEWED, key, freshToken, oldToken);
  }

  emitAdded(key, token) {
    this.emitter.emit(EVENT_ADDED, key, token);
  }

  emitRemoved(key, token) {
    this.emitter.emit(EVENT_REMOVED, key, token);
  }

  emitError(error) {
    this.emitter.emit(EVENT_ERROR, error);
  }

  emitEventsForCrossTabsStorageUpdate(newValue, oldValue) {
    var oldTokens = this.getTokensFromStorageValue(oldValue);
    var newTokens = this.getTokensFromStorageValue(newValue);
    Object.keys(newTokens).forEach(key => {
      var oldToken = oldTokens[key];
      var newToken = newTokens[key];

      if (JSON.stringify(oldToken) !== JSON.stringify(newToken)) {
        this.emitAdded(key, newToken);
      }
    });
    Object.keys(oldTokens).forEach(key => {
      var oldToken = oldTokens[key];
      var newToken = newTokens[key];

      if (!newToken) {
        this.emitRemoved(key, oldToken);
      }
    });
  }

  clearExpireEventTimeout(key) {
    clearTimeout(this.state.expireTimeouts[key]);
    delete this.state.expireTimeouts[key]; // Remove the renew promise (if it exists)

    delete this.state.renewPromise[key];
  }

  clearExpireEventTimeoutAll() {
    var expireTimeouts = this.state.expireTimeouts;

    for (var key in expireTimeouts) {
      if (!Object.prototype.hasOwnProperty.call(expireTimeouts, key)) {
        continue;
      }

      this.clearExpireEventTimeout(key);
    }
  }

  setExpireEventTimeout(key, token) {
    if (isRefreshToken(token)) {
      return;
    }

    var expireTime = this.getExpireTime(token);
    var expireEventWait = Math.max(expireTime - this.clock.now(), 0) * 1000; // Clear any existing timeout

    this.clearExpireEventTimeout(key);
    var expireEventTimeout = setTimeout(() => {
      this.emitExpired(key, token);
    }, expireEventWait); // Add a new timeout

    this.state.expireTimeouts[key] = expireEventTimeout;
  }

  setExpireEventTimeoutAll() {
    var tokenStorage = this.storage.getStorage();

    for (var key in tokenStorage) {
      if (!Object.prototype.hasOwnProperty.call(tokenStorage, key)) {
        continue;
      }

      var token = tokenStorage[key];
      this.setExpireEventTimeout(key, token);
    }
  } // reset timeouts to setup autoRenew for tokens from other document context (tabs)


  resetExpireEventTimeoutAll() {
    this.clearExpireEventTimeoutAll();
    this.setExpireEventTimeoutAll();
  }

  add(key, token) {
    var tokenStorage = this.storage.getStorage();
    validateToken(token);
    tokenStorage[key] = token;
    this.storage.setStorage(tokenStorage);
    this.emitAdded(key, token);
    this.setExpireEventTimeout(key, token);
  }

  getSync(key) {
    var tokenStorage = this.storage.getStorage();
    return tokenStorage[key];
  }

  get(key) {
    var _this = this;

    return _asyncToGenerator(function* () {
      return _this.getSync(key);
    })();
  }

  getTokensSync() {
    var tokens = {};
    var tokenStorage = this.storage.getStorage();
    Object.keys(tokenStorage).forEach(key => {
      var token = tokenStorage[key];

      if (isAccessToken(token)) {
        tokens.accessToken = token;
      } else if (isIDToken(token)) {
        tokens.idToken = token;
      } else if (isRefreshToken(token)) {
        tokens.refreshToken = token;
      }
    });
    return tokens;
  }

  getTokens() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      return _this2.getTokensSync();
    })();
  }

  getStorageKeyByType(type) {
    var tokenStorage = this.storage.getStorage();
    var key = Object.keys(tokenStorage).filter(key => {
      var token = tokenStorage[key];
      return isAccessToken(token) && type === 'accessToken' || isIDToken(token) && type === 'idToken' || isRefreshToken(token) && type === 'refreshToken';
    })[0];
    return key;
  } // eslint-disable-next-line complexity


  setTokens(_ref, accessTokenCb, idTokenCb, refreshTokenCb) {
    var {
      accessToken,
      idToken,
      refreshToken
    } = _ref;

    var handleAdded = (key, token, tokenCb) => {
      this.emitAdded(key, token);
      this.setExpireEventTimeout(key, token);

      if (tokenCb) {
        tokenCb(key, token);
      }
    };

    var handleRemoved = (key, token, tokenCb) => {
      this.clearExpireEventTimeout(key);
      this.emitRemoved(key, token);

      if (tokenCb) {
        tokenCb(key, token);
      }
    };

    if (idToken) {
      validateToken(idToken, 'idToken');
    }

    if (accessToken) {
      validateToken(accessToken, 'accessToken');
    }

    if (refreshToken) {
      validateToken(refreshToken, 'refreshToken');
    }

    var idTokenKey = this.getStorageKeyByType('idToken') || ID_TOKEN_STORAGE_KEY;
    var accessTokenKey = this.getStorageKeyByType('accessToken') || ACCESS_TOKEN_STORAGE_KEY;
    var refreshTokenKey = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY; // add token to storage

    var tokenStorage = _objectSpread(_objectSpread(_objectSpread({}, idToken && {
      [idTokenKey]: idToken
    }), accessToken && {
      [accessTokenKey]: accessToken
    }), refreshToken && {
      [refreshTokenKey]: refreshToken
    });

    this.storage.setStorage(tokenStorage); // emit event and start expiration timer

    var existingTokens = this.getTokensSync();

    if (idToken) {
      handleAdded(idTokenKey, idToken, idTokenCb);
    } else if (existingTokens.idToken) {
      handleRemoved(idTokenKey, existingTokens.idToken, idTokenCb);
    }

    if (accessToken) {
      handleAdded(accessTokenKey, accessToken, accessTokenCb);
    } else if (existingTokens.accessToken) {
      handleRemoved(accessTokenKey, existingTokens.accessToken, accessTokenCb);
    }

    if (refreshToken) {
      handleAdded(refreshTokenKey, refreshToken, refreshTokenCb);
    } else if (existingTokens.refreshToken) {
      handleRemoved(refreshTokenKey, existingTokens.refreshToken, refreshTokenCb);
    }
  }
  /* eslint-enable max-params */


  remove(key) {
    // Clear any listener for this token
    this.clearExpireEventTimeout(key);
    var tokenStorage = this.storage.getStorage();
    var removedToken = tokenStorage[key];
    delete tokenStorage[key];
    this.storage.setStorage(tokenStorage);
    this.emitRemoved(key, removedToken);
  } // TODO: this methods is redundant and can be removed in the next major version OKTA-407224


  renewToken(token) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      return _this3.sdk.token.renew(token);
    })();
  } // TODO: this methods is redundant and can be removed in the next major version OKTA-407224


  validateToken(token) {
    return validateToken(token);
  }

  renew(key) {
    // Multiple callers may receive the same promise. They will all resolve or reject from the same request.
    var existingPromise = this.state.renewPromise[key];

    if (existingPromise) {
      return existingPromise;
    }

    try {
      var token = this.getSync(key);

      if (!token) {
        throw new AuthSdkError('The tokenManager has no token for the key: ' + key);
      }
    } catch (e) {
      return Promise.reject(e);
    } // Remove existing autoRenew timeout


    this.clearExpireEventTimeout(key); // A refresh token means a replace instead of renewal
    // Store the renew promise state, to avoid renewing again

    this.state.renewPromise[key] = this.sdk.token.renew(token).then(freshToken => {
      // store and emit events for freshToken
      var oldTokenStorage = this.storage.getStorage();
      this.remove(key);
      this.add(key, freshToken);
      this.emitRenewed(key, freshToken, oldTokenStorage[key]);
      return freshToken;
    }).catch(err => {
      // If renew fails, remove token and emit error
      if (isRefreshTokenError(err) || err.name === 'OAuthError' || err.name === 'AuthSdkError') {
        // remove token from storage
        this.remove(key);
        err.tokenKey = key;
        this.emitError(err);
      }

      throw err;
    }).finally(() => {
      // Remove existing promise key
      delete this.state.renewPromise[key];
    });
    return this.state.renewPromise[key];
  }

  clear() {
    this.clearExpireEventTimeoutAll();
    this.storage.clearStorage();
  }

  getTokensFromStorageValue(value) {
    var tokens;

    try {
      tokens = JSON.parse(value) || {};
    } catch (e) {
      tokens = {};
    }

    return tokens;
  }

  updateRefreshToken(token) {
    var key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY; // do not emit any event

    var tokenStorage = this.storage.getStorage();
    validateToken(token);
    tokenStorage[key] = token;
    this.storage.setStorage(tokenStorage);
  }

}

if (isLocalhost()) {
  (function addWarningsForLocalhost() {
    var {
      add: _add
    } = TokenManager.prototype;
    Object.assign(TokenManager.prototype, {
      add: function add(key, token) {
        warn('Use setTokens() instead if you want to add a set of tokens at same time.\n' + 'It prevents current tab from emitting unnecessary StorageEvent,\n' + 'which may cause false-positive authState change cross tabs.');

        _add.call(this, key, token);
      }
    });
  })();
}
//# sourceMappingURL=TokenManager.js.map